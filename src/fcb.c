#include "fcb.h"
#include "system.h"

// Fully automatic FPGA configuration. config_addr must point to configuration bit stream generated by Supra software
ReturnCodeTypedef FCB_AutoConfig(uint32_t config_addr)
{
  FCB->CTRL = FCB_CTRL_AUTO;
  uint32_t *ptr = (uint32_t *)config_addr;
  for (int i = 0; i < FCB_AUTO_WORDS; ++i) {
    FCB->AUTO = *ptr++;
  }
  return (FCB_IsActive() && !FCB_IsAnyError()) ? RET_OK : RET_ERR;
}

// The DMA version is about 2x faster  
ReturnCodeTypedef FCB_AutoConfigDma(uint32_t config_addr, DMAC_ChannelNumTypeDef channel)
{
  FCB->CTRL = FCB_CTRL_AUTO;
  DMAC_WaitedTransfer(channel, config_addr, (uint32_t)(&FCB->AUTO), DMAC_ADDR_INCR_ON, DMAC_ADDR_INCR_OFF,
                      DMAC_WIDTH_32_BIT, DMAC_WIDTH_32_BIT, DMAC_BURST_256, DMAC_BURST_256, FCB_AUTO_WORDS,
                      DMAC_MEM_TO_MEM_DMA_CTRL, 0, 0);
  return (FCB_IsActive() && !FCB_IsAnyError()) ? RET_OK : RET_ERR;
}

ReturnCodeTypedef FCB_AutoDecompressEncrypt(uint32_t config_addr, uint8_t(*encrypt_decode)(uint8_t))
{
#define LZW_DATA_WIDTH 8
#define LZW_MAX_INDEX 1023

#define MAX_DATA    ((1 << LZW_DATA_WIDTH) - 1)
#define CLEAR_INDEX (MAX_DATA + 1)
#define STOP_INDEX  (MAX_DATA + 2)
#define MIN_INDEX   (MAX_DATA + 3)

  FCB->CTRL = FCB_CTRL_AUTO;
  FCB->AUTO = *(uint32_t *)(config_addr + 0); // IDCODE
  FCB->AUTO = *(uint32_t *)(config_addr + 4); // USERID
  uint8_t *ptr = (uint8_t *)(config_addr + 8);

  uint32_t fcb_word = 0;
  int fcb_byte_count = 0;

  int index_width = LZW_DATA_WIDTH + 1;
  int index_mask = (1 << index_width) - 1;
  int decode_index = MIN_INDEX - MAX_DATA;
  int prev_index = -1;
  uint8_t prev_data0 = 0;

  // Each dict entry is a pair of index + data
  int dict_index[LZW_MAX_INDEX + 1];
  uint8_t dict_data[LZW_MAX_INDEX + 1];

  int bits = 0;
  uint32_t data = 0;
  while (1) {
    data = (data << 8) | (encrypt_decode?encrypt_decode(*ptr++):(*ptr++));
    bits += 8;
    while (bits >= index_width) {
      // Get the compressed index
      bits -= index_width;
      int index = (data >> bits) & index_mask;

      if (index == CLEAR_INDEX) {
        index_width = LZW_DATA_WIDTH + 1;
        index_mask = (1 << index_width) - 1;
        decode_index = MIN_INDEX - MAX_DATA;
        prev_index = -1;
        continue;
      } else if (index == STOP_INDEX) {
        return RET_ERR;
      }

      if (index == decode_index + MAX_DATA) {
        // Construct this index by adding the first data from previous index
        dict_index[decode_index] = prev_index;
        dict_data[decode_index] = prev_data0;
      }
      if (index > decode_index + MAX_DATA) {
        return RET_ERR; // Unknown index
      }

      // Construct decode output data in decode_array reversely
      uint8_t decode_array[LZW_MAX_INDEX + 1];
      uint8_t *decode_ptr = decode_array;
      for (int decode_data = index; ; ) {
        if (decode_data <= MAX_DATA) {
          *decode_ptr = decode_data; // The first data for this index
          prev_data0 = decode_data;
          break;
        } else {
          decode_data -= MAX_DATA;
          *decode_ptr++ = dict_data[decode_data];
          decode_data = dict_index[decode_data];
        }
      };

      if (prev_index >= 0) {
        dict_index[decode_index] = prev_index;
        dict_data[decode_index] = *decode_ptr;
        ++decode_index;
        if (decode_index + MAX_DATA > index_mask) {
          ++index_width;
          index_mask = (index_mask << 1) | 1;
        }
      }
      prev_index = index;

      for (; decode_ptr >= decode_array; --decode_ptr) {
        fcb_word = (fcb_word >> 8) | (*decode_ptr << 24);
        if (++fcb_byte_count % 4 == 0) {
          FCB->AUTO = fcb_word;
          if (fcb_byte_count == FCB_AUTO_WORDS * 4 - 8) {
            return (FCB_IsActive() && !FCB_IsAnyError()) ? RET_OK : RET_ERR;
          }
        }
      }
    }
  }
  return RET_ERR;
}

void FCB_ReadIOConfig(FCB_IO_TypeDef *io_cfg)
{
  FCB0->ADDR = FCB_IO_ADDR;
  FCB0->CTRL = FCB_CTRL_READ;
  for (int i = 0; i < FCB_IO_WORDS; ++i) {
    io_cfg->WORDS[i] = FCB0->DATA;
  }
}

void FCB_WriteIOConfig(FCB_IO_TypeDef *io_cfg)
{
  FCB0->ADDR = FCB_IO_ADDR;
  FCB0->CTRL = FCB_CTRL_WRITE | FCB_CTRL_UPDATE;
  for (int i = 0; i < FCB_IO_WORDS; ++i) {
    FCB0->DATA = io_cfg->WORDS[i];
  }
}

void FCB_GetOscConfig(FCB_IO_TypeDef *io_cfg, FCB_OSC_TypeDef *osc_cfg)
{
  osc_cfg->BYTES[0] = UTIL_ReverseBits(io_cfg->RC_OSC[0]);
  osc_cfg->BYTES[1] = UTIL_ReverseBits(io_cfg->RC_OSC[1]);
}

void FCB_SetOscConfig(FCB_IO_TypeDef *io_cfg, FCB_OSC_TypeDef *osc_cfg)
{
  io_cfg->RC_OSC[0] = UTIL_ReverseBits(osc_cfg->BYTES[0]);
  io_cfg->RC_OSC[1] = UTIL_ReverseBits(osc_cfg->BYTES[1]);
}

void FCB_ReadPLLConfig(FCB_PLL_Typedef *pll_cfg)
{
  FCB0->ADDR = FCB_PLL_ADDR;
  FCB0->CTRL = FCB_CTRL_READ;
  for (int i = 0; i < FCB_PLL_WORDS; ++i) {
    pll_cfg->WORDS[i] = FCB0->DATA;
    for (int j = i * 4; j < i * 4 + 4; ++j) {
      pll_cfg->BYTES[j] = UTIL_ReverseBits(pll_cfg->BYTES[j]);
    }
  }
}

void FCB_WritePLLConfig(FCB_PLL_Typedef *pll_cfg)
{
  FCB0->ADDR = FCB_PLL_ADDR;
  FCB0->CTRL = FCB_CTRL_WRITE | FCB_CTRL_UPDATE;
  for (int i = 0; i < FCB_PLL_WORDS; ++i) {
    for (int j = i * 4; j < i * 4 + 4; ++j) {
      pll_cfg->BYTES[j] = UTIL_ReverseBits(pll_cfg->BYTES[j]);
    }
    FCB0->DATA = pll_cfg->WORDS[i];
  }
}
